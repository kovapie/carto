@model QuickGraph.BidirectionalGraph<carto.Models.CmdbItem, carto.Models.CmdbDependency>

@{
    ViewBag.Title = "Application Inventory";
}

<style type="text/css">
    svg
    {
        background-color: white;
    }

    svg.ctrl {
        cursor: crosshair;
    }

    .overlay
    {
        fill: none;
        pointer-events: all;
    }

    .node
    {
        fill: orange;
        cursor: pointer;
    }

    .node.selected circle {
        stroke: orange;
        stroke-width: 4px;
    }

    path.link
    {
        fill: none;
        stroke: #999;
        stroke-width: 4px;
        marker-end: url(#end-arrow);
        cursor: default;
    }

    path.link.selected {
  stroke-dasharray: 10,2;
}

path.link.dragline {
  pointer-events: none;
}

path.link.hidden {
  stroke-width: 0;
}

    text.label
    {
        fill: black;
        /*text-anchor: middle;*/
    }

    .Desktop
    {
        fill: blue;
        opacity: 0.5;
    }

    .Service
    {
        fill: green;
        opacity: 0.5;
    }
</style>

<p>
    @Html.ActionLink("Report", "Report")
</p>

<p>Filter accepts OData expressions. e.g: Vertex/Name eq 'RaDaR'</p>
<p>Ctrl click on the graph to create a new node. If a node is selected, it will be cloned.</p>
<p>Ctrl click and drag from a node to create a dependency.</p>

<div id="container" style="width: 100%">
    <button id="getgraph">Filter</button>
    <input id="filter" type="text" />
    <svg class="graph">
        <defs>
            <marker id="end-arrow" viewBox="0 -5 10 10" refX="6" markerWidth="3" markerHeight="3" orient="auto">
                <path d="M0,-5L10,0L0,5" fill="#999" />
            </marker>
        </defs>
        <path class="link dragline hidden" d="M0,0L0,0" />
    </svg>
</div>

<aside data-bind="if: selectedItem">
    <p> Id: <!--ko text: selectedItem().id--><!--/ko--> -v.<!--ko text: selectedItem().version--><!--/ko-->  </p>
    <p>Name:
        <input data-bind="value: selectedItem().name" /></p>
    <p>Description:
        <input data-bind="value: selectedItem().description" /></p>
</aside>

<aside data-bind="if: selectedLink">
    <p> Id: <!--ko text: selectedLink().id--><!--/ko--> -v.<!--ko text: selectedLink().version--><!--/ko-->  </p>
    <p>Source:
        <span data-bind="text: selectedLink().source.name" /></p>
    <p>Target:
        <span data-bind="text: selectedLink().target.name" /></p>
</aside>


<script>
    var width = 960,
        height = 500;

    var force = d3.layout.force()
        .size([width, height])
        .linkDistance(150)
        .charge(-500)
        .on("tick", tick);

    var svg = d3.select("svg")
        .attr("width", width)
        .attr("height", height)
        .on("mousedown", onMouseDown)
        .on("mouseup", onMouseUp)
        .on("mousemove", onMouseMove);

    svg.append("rect")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height)
    .call(d3.behavior.zoom().scaleExtent([0.5, 2]).on("zoom", zoom));
    
    var vis = svg.append("g");
    var dragline = svg.select(".dragline");

    var viewModel = new GraphViewModel();
    ko.applyBindings(viewModel);

    var link = vis.selectAll(".link"),
        node = vis.selectAll(".node");

    loadgraph();

    function zoom() {
        vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    function tick() {
        link.attr("d", function (d) {
            var deltaX = d.target.x - d.source.x,
                deltaY = d.target.y - d.source.y,
                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                normX = deltaX / dist,
                normY = deltaY / dist,
                //sourcePadding = d.left ? 17 : 12,
                //targetPadding = d.right ? 17 : 12,
                sourcePadding = 12,
                targetPadding = 17,
                sourceX = d.source.x + (sourcePadding * normX),
                sourceY = d.source.y + (sourcePadding * normY),
                targetX = d.target.x - (targetPadding * normX),
                targetY = d.target.y - (targetPadding * normY);
            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
        });

        node.attr('transform', function (d) {
            return 'translate(' + d.x + ',' + d.y + ')';
        });
    }

    function loadgraph() {
        var filter = $("#filter").val();
        var uri = filter == "" ? "api/graph/node" : "api/graph/node?$filter=" + filter;
        $.getJSON(uri)
            .done(drawgraph)
            .fail(function (error) { alert(error); });
    }

    function drawgraph(graphdata) {
        viewModel.update(graphdata);
        redraw();
    }
    
    function redraw() {
        force.nodes(viewModel.nodes())
            .links(viewModel.links())
            .start();

        link = link.data(viewModel.links());
        link.exit().remove();
        link.enter().append("path").attr("class", "link");
        link.classed("selected", function (d) {
            return d === viewModel.selectedLink();
        });
        link.on("click", onLinkClicked);

        node = node.data(viewModel.nodes(), function (d) { return d.id; });
        node.exit().remove();

        var g = node.enter().append("g").attr("class", "node");
        g.append("circle").attr("class", function (d) { return d.innerNode.Attributes[1]; }).attr("r", 12);
        g.append("text").attr("class", "label");
        g.append("title");
        node.classed("selected", function (d) {
            return d === viewModel.selectedItem();
        });

        node.select("text").text(function (d) { return d.name(); });
        node.select("title").text(function (d) { return d.description(); });

        node.on("click", click)
        .on("mousedown", onNodeMouseDown)
        .on("mouseup", onNodeMouseUp)
            .call(force.drag);

        force.drag().on("dragstart", dragstart);

        function dragstart(d) {
            d.fixed = true;
        }

        function click(n) {
            //if (d3.event.defaultPrevented) return;
            if (d3.event.shiftKey && n.fixed) {
                n.fixed = false;
            }
            if (n === viewModel.selectedItem()) {
                viewModel.selectedItem(null);
            } else {
                viewModel.selectedItem(n);
                viewModel.selectedLink(null);
            }
            redraw();
        }
        
        function onLinkClicked(l) {
            if (l === viewModel.selectedLink()) {
                viewModel.selectedLink(null);
            } else {
                viewModel.selectedLink(l);
                viewModel.selectedItem(null);
            }
            redraw();
        }

        function onNodeMouseDown(node) {
            if (d3.event.ctrlKey) {
                viewModel.fromItem(node);
                dragline
                  .classed('hidden', false)
                  .attr('d', 'M' + viewModel.fromItem().x + ',' + viewModel.fromItem().y + 'L' + viewModel.fromItem().x + ',' + viewModel.fromItem().y);
                redraw();
            }
        }

        function onNodeMouseUp(node) {
            if (viewModel.fromItem() && d3.event.ctrlKey) {
                if (viewModel.fromItem() !== node) {
                    createLink({ source: viewModel.fromItem(), target: node });
                }
            }
            viewModel.resetDragLine();
        }
    }

    function onSave(node) {
        if (!node) {
            node = viewModel.selectedItem();
        }
        var  vertex = node.toDto();
        $.ajax({
            type: "PUT",
            contentType: "application/json;charset=utf-8",
            url: "api/graph/node/" + vertex.Id,
            data: JSON.stringify(vertex),
        }).done(function (savedNode) {
            viewModel.updateNode(new CmdbViewModel(savedNode));
        });
    }
    
    function onCreate(point) {
        var vertex=null;
        if (viewModel.selectedItem() != null) {
            vertex = viewModel.selectedItem().toDto();
        }
        $.ajax({
            type: "POST",
            contentType: "application/json;charset=utf-8",
            url: "api/graph/node",
            data: JSON.stringify(vertex),
        }).done(function (node) {
            var nodevm = new CmdbViewModel(node);
            nodevm.x = point[0];
            nodevm.y = point[1];
            viewModel.addNode(nodevm);
        });
    }
    
    function onDelete() {
        var vertex = viewModel.selectedItem();
        $.ajax({
            type: "DELETE",
            url: "api/graph/node/" + vertex.id,
        }).done(function (isDeleted) {
            if (isDeleted) {
                viewModel.deleteNode(vertex);
            }
        });
    }

    function createLink(link) {
        $.ajax({
            type: "POST",
            contentType: "application/json;charset=utf-8",
            url: "api/graph/link",
            data: JSON.stringify(link),
        }).done(function (edge) {
            edge.source = link.source;
            edge.target = link.target;
            var linkvm = new LinkViewModel(edge);            
            viewModel.addLink(linkvm);
        });
    }

    function onDeleteLink() {
        var selectedLink = viewModel.selectedLink();
        $.ajax({
            type: "DELETE",
            url: "api/graph/link/" + selectedLink.id,
        }).done(function (isDeleted) {
            if (isDeleted) {
                viewModel.deleteLink(selectedLink);
            }
        });
    }

    function onKeyDown(event) {
        switch (event.which) {
            case 17: //ctrl
                node.on("mousedown.drag", null);
                svg.classed("ctrl", true);
                break;
            case 46: //del
                if (event.ctrlKey) {
                    if (viewModel.selectedItem()) {
                        onDelete();
                    }
                    if (viewModel.selectedLink()) {
                        onDeleteLink();
                    }
                }
                break;
            case 45: //ins
                if (event.ctrlKey) {
                    onCreate({});
                }
                break;
            case 109: //num -
            case 107: //num +
                //TODO expand/collapse node
                break;
        }
    }

    function onKeyUp(event) {
        if (event.which === 17) {
            node.call(force.drag);
            svg.classed("ctrl", false);
            viewModel.resetDragLine();
        }
    }

    function onMouseDown() {
        if (d3.event.ctrlKey && !viewModel.fromItem()) {
            onCreate(d3.mouse(this));
        }
    }

    function onMouseUp() {
        viewModel.resetDragLine();
    }
    
    function onMouseMove() {
        if (!viewModel.fromItem()) return;
        dragline.attr('d', 'M' + viewModel.fromItem().x + ',' + viewModel.fromItem().y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);
        redraw();
    }

    $(function () {
        $("#getgraph").click(loadgraph);

        $(document)
            .keydown(onKeyDown)
            .keyup(onKeyUp);
    });

    function CmdbViewModel(node) {
        var self = this;
        this.innerNode = node;
        this.id = node.Id;
        this.version = node.Version;
        this.name = ko.observable(node.Name);
        this.description = ko.observable(node.Description);
        this.isDirty = ko.computed(function () { return { name: self.name(), description: self.description() }; });

        this.toDto = function() {
            this.innerNode.Name = this.name();
            this.innerNode.Description = this.description();
            return this.innerNode;
        };
    }
    
    function LinkViewModel(link) {
        var self = this;
        this.innerLink = link;
        this.id = link.Id;
        this.version = link.version;
        this.source = link.source;
        this.target = link.target;

        this.toDto = function() {
            self.innerLink.SourceId = self.source().id;
            self.innerLink.TargetId = self.target().id;
            return self.innerLink;
        };
    }

    function GraphViewModel() {
        var self = this;
        var subs = [];
        this.nodes = ko.observableArray();
        this.links = ko.observableArray();

        this.selectedItem = ko.observable();
        this.selectedLink = ko.observable();
        this.canSave = ko.computed(function () { return self.selectedItem() != null; });

        this.fromItem = ko.observable();

        this.update = function (graphdata) {
            ko.utils.arrayForEach(subs, function (sub) { sub.dispose(); });
            this.nodes.removeAll();
            this.links.removeAll();
            this.selectedItem(null);
            this.selectedLink(null);
            var alllinks = new Array();
            var nodeMap = {};

            for (var i = 0; i < graphdata.length; i++) {
                var item = graphdata[i];
                var vertex = item.vertex;
                var edges = item.edges;
                var itemviewmodel = new CmdbViewModel(vertex);
                nodeMap[vertex.Id] = itemviewmodel;
                this.nodes.push(itemviewmodel);
                subs.push(itemviewmodel.isDirty.subscribe(function () {
                    onSave(itemviewmodel);
                    redraw();
                }));
                for (var j = 0; j < edges.length; j++) {
                    alllinks.push(edges[j]);
                }
            }

            for (var k = 0; k < alllinks.length; k++) {
                var edge = alllinks[k];
                if (edge.TargetId in nodeMap) {
                    edge.target = nodeMap[edge.TargetId];
                    edge.source = nodeMap[edge.SourceId];
                    this.links.push(new LinkViewModel(edge));
                }
            }
        };

        this.updateNode = function(node) {
            for (var i = 0; i < this.nodes().length; i++) {
                var currentNode = this.nodes()[i];
                if (currentNode.id === node.id && currentNode.version < node.version) {
                    //TODO remove and dispose subscription to old node
                    subs.push(node.isDirty.subscribe(function () {
                        onSave(node);
                        redraw();
                    }));
                    node.x = currentNode.x;
                    node.y = currentNode.y;
                    this.nodes()[i] = node;
                    for (var j = 0; j < this.links().length; j++) {
                        var currentLink = this.links()[j];
                        if (currentLink.target === currentNode) {
                            currentLink.target = node;                            
                        }
                        if (currentLink.source === currentNode) {
                            currentLink.source = node;
                        }
                    }
                    if (self.selectedItem() === currentNode) {
                        self.selectedItem(node);
                        self.selectedLink(null);
                    }
                    redraw();
                    return true;
                }  
            }
            return false;
        };

        this.addNode = function (node) {
            this.nodes.push(node);
            subs.push(node.isDirty.subscribe(function () {
                onSave(node);
                redraw();
            }));
            viewModel.selectedItem(node);
            viewModel.selectedLink(null);
            redraw();
        };

        this.deleteNode = function (node) {
            //TODO remove and dispose subscription for this node
            self.links.remove(function(item) {
                return (item.source === node || item.target === node);
            });
            self.nodes.remove(node);
            if (viewModel.selectedItem() === node) {
                viewModel.selectedItem(null);
            }
            redraw();
        };

        this.addLink = function (link) {
            this.links.push(link);
            viewModel.selectedLink(link);
            viewModel.selectedItem(null);
            redraw();
        };

        this.deleteLink = function (link) {
            self.links.remove(link);
            if (viewModel.selectedLink() === link) {
                viewModel.selectedLink(null);
            }
            redraw();
        };

        this.resetDragLine = function() {
            this.fromItem(null);
            dragline.classed("hidden", true);
        };
    }

</script>
